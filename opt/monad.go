// Code generated by generate_monad.go; DO NOT EDIT.
package opt

//go:generate go run internal/generate/generate_monad.go
import (
	"context"
)

func ApplyOn1[T1 any](
	t1 Opt[T1],
	fn func(t1 T1),
) {
	v1, ok1 := t1.Get()

	if ok1 {
		fn(v1)
	}

	return
}

func ApplyCtxOn1[T1 any](
	ctx context.Context, t1 Opt[T1],
	fn func(ctx context.Context, t1 T1),
) {
	v1, ok1 := t1.Get()

	if ok1 {
		fn(ctx, v1)
	}

	return
}

func ApplyErrOn1[T1 any](
	t1 Opt[T1],
	fn func(t1 T1) (err error),
) (err error) {
	v1, ok1 := t1.Get()

	if ok1 {
		return fn(v1)
	}

	return
}

func ApplyCtxErrOn1[T1 any](
	ctx context.Context, t1 Opt[T1],
	fn func(ctx context.Context, t1 T1) (err error),
) (err error) {
	v1, ok1 := t1.Get()

	if ok1 {
		return fn(ctx, v1)
	}

	return
}

func Apply[T1, R1 any](
	t1 Opt[T1],
	fn func(t1 T1) (r1 R1),
) (r1 Opt[R1]) {
	v1, ok1 := t1.Get()

	if ok1 {
		x1 := fn(v1)

		return Literal(x1)
	}

	return
}

func ApplyCtx[T1, R1 any](
	ctx context.Context, t1 Opt[T1],
	fn func(ctx context.Context, t1 T1) (r1 R1),
) (r1 Opt[R1]) {
	v1, ok1 := t1.Get()

	if ok1 {
		x1 := fn(ctx, v1)

		return Literal(x1)
	}

	return
}

func ApplyErr[T1, R1 any](
	t1 Opt[T1],
	fn func(t1 T1) (r1 R1, err error),
) (r1 Opt[R1], err error) {
	v1, ok1 := t1.Get()

	if ok1 {
		x1, err := fn(v1)

		return Literal(x1), err
	}

	return
}

func ApplyCtxErr[T1, R1 any](
	ctx context.Context, t1 Opt[T1],
	fn func(ctx context.Context, t1 T1) (r1 R1, err error),
) (r1 Opt[R1], err error) {
	v1, ok1 := t1.Get()

	if ok1 {
		x1, err := fn(ctx, v1)

		return Literal(x1), err
	}

	return
}

func Apply12[T1, R1, R2 any](
	t1 Opt[T1],
	fn func(t1 T1) (r1 R1, r2 R2),
) (r1 Opt[R1], r2 Opt[R2]) {
	v1, ok1 := t1.Get()

	if ok1 {
		x1, x2 := fn(v1)

		return Literal(x1), Literal(x2)
	}

	return
}

func ApplyCtx12[T1, R1, R2 any](
	ctx context.Context, t1 Opt[T1],
	fn func(ctx context.Context, t1 T1) (r1 R1, r2 R2),
) (r1 Opt[R1], r2 Opt[R2]) {
	v1, ok1 := t1.Get()

	if ok1 {
		x1, x2 := fn(ctx, v1)

		return Literal(x1), Literal(x2)
	}

	return
}

func ApplyErr12[T1, R1, R2 any](
	t1 Opt[T1],
	fn func(t1 T1) (r1 R1, r2 R2, err error),
) (r1 Opt[R1], r2 Opt[R2], err error) {
	v1, ok1 := t1.Get()

	if ok1 {
		x1, x2, err := fn(v1)

		return Literal(x1), Literal(x2), err
	}

	return
}

func ApplyCtxErr12[T1, R1, R2 any](
	ctx context.Context, t1 Opt[T1],
	fn func(ctx context.Context, t1 T1) (r1 R1, r2 R2, err error),
) (r1 Opt[R1], r2 Opt[R2], err error) {
	v1, ok1 := t1.Get()

	if ok1 {
		x1, x2, err := fn(ctx, v1)

		return Literal(x1), Literal(x2), err
	}

	return
}

func ApplyOn2[T1, T2 any](
	t1 Opt[T1], t2 Opt[T2],
	fn func(t1 T1, t2 T2),
) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()

	if ok1 && ok2 {
		fn(v1, v2)
	}

	return
}

func ApplyCtxOn2[T1, T2 any](
	ctx context.Context, t1 Opt[T1], t2 Opt[T2],
	fn func(ctx context.Context, t1 T1, t2 T2),
) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()

	if ok1 && ok2 {
		fn(ctx, v1, v2)
	}

	return
}

func ApplyErrOn2[T1, T2 any](
	t1 Opt[T1], t2 Opt[T2],
	fn func(t1 T1, t2 T2) (err error),
) (err error) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()

	if ok1 && ok2 {
		return fn(v1, v2)
	}

	return
}

func ApplyCtxErrOn2[T1, T2 any](
	ctx context.Context, t1 Opt[T1], t2 Opt[T2],
	fn func(ctx context.Context, t1 T1, t2 T2) (err error),
) (err error) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()

	if ok1 && ok2 {
		return fn(ctx, v1, v2)
	}

	return
}

func Apply2[T1, T2, R1 any](
	t1 Opt[T1], t2 Opt[T2],
	fn func(t1 T1, t2 T2) (r1 R1),
) (r1 Opt[R1]) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()

	if ok1 && ok2 {
		x1 := fn(v1, v2)

		return Literal(x1)
	}

	return
}

func ApplyCtx2[T1, T2, R1 any](
	ctx context.Context, t1 Opt[T1], t2 Opt[T2],
	fn func(ctx context.Context, t1 T1, t2 T2) (r1 R1),
) (r1 Opt[R1]) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()

	if ok1 && ok2 {
		x1 := fn(ctx, v1, v2)

		return Literal(x1)
	}

	return
}

func ApplyErr2[T1, T2, R1 any](
	t1 Opt[T1], t2 Opt[T2],
	fn func(t1 T1, t2 T2) (r1 R1, err error),
) (r1 Opt[R1], err error) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()

	if ok1 && ok2 {
		x1, err := fn(v1, v2)

		return Literal(x1), err
	}

	return
}

func ApplyCtxErr2[T1, T2, R1 any](
	ctx context.Context, t1 Opt[T1], t2 Opt[T2],
	fn func(ctx context.Context, t1 T1, t2 T2) (r1 R1, err error),
) (r1 Opt[R1], err error) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()

	if ok1 && ok2 {
		x1, err := fn(ctx, v1, v2)

		return Literal(x1), err
	}

	return
}

func Apply22[T1, T2, R1, R2 any](
	t1 Opt[T1], t2 Opt[T2],
	fn func(t1 T1, t2 T2) (r1 R1, r2 R2),
) (r1 Opt[R1], r2 Opt[R2]) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()

	if ok1 && ok2 {
		x1, x2 := fn(v1, v2)

		return Literal(x1), Literal(x2)
	}

	return
}

func ApplyCtx22[T1, T2, R1, R2 any](
	ctx context.Context, t1 Opt[T1], t2 Opt[T2],
	fn func(ctx context.Context, t1 T1, t2 T2) (r1 R1, r2 R2),
) (r1 Opt[R1], r2 Opt[R2]) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()

	if ok1 && ok2 {
		x1, x2 := fn(ctx, v1, v2)

		return Literal(x1), Literal(x2)
	}

	return
}

func ApplyErr22[T1, T2, R1, R2 any](
	t1 Opt[T1], t2 Opt[T2],
	fn func(t1 T1, t2 T2) (r1 R1, r2 R2, err error),
) (r1 Opt[R1], r2 Opt[R2], err error) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()

	if ok1 && ok2 {
		x1, x2, err := fn(v1, v2)

		return Literal(x1), Literal(x2), err
	}

	return
}

func ApplyCtxErr22[T1, T2, R1, R2 any](
	ctx context.Context, t1 Opt[T1], t2 Opt[T2],
	fn func(ctx context.Context, t1 T1, t2 T2) (r1 R1, r2 R2, err error),
) (r1 Opt[R1], r2 Opt[R2], err error) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()

	if ok1 && ok2 {
		x1, x2, err := fn(ctx, v1, v2)

		return Literal(x1), Literal(x2), err
	}

	return
}

func ApplyOn3[T1, T2, T3 any](
	t1 Opt[T1], t2 Opt[T2], t3 Opt[T3],
	fn func(t1 T1, t2 T2, t3 T3),
) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()
	v3, ok3 := t3.Get()

	if ok1 && ok2 && ok3 {
		fn(v1, v2, v3)
	}

	return
}

func ApplyCtxOn3[T1, T2, T3 any](
	ctx context.Context, t1 Opt[T1], t2 Opt[T2], t3 Opt[T3],
	fn func(ctx context.Context, t1 T1, t2 T2, t3 T3),
) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()
	v3, ok3 := t3.Get()

	if ok1 && ok2 && ok3 {
		fn(ctx, v1, v2, v3)
	}

	return
}

func ApplyErrOn3[T1, T2, T3 any](
	t1 Opt[T1], t2 Opt[T2], t3 Opt[T3],
	fn func(t1 T1, t2 T2, t3 T3) (err error),
) (err error) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()
	v3, ok3 := t3.Get()

	if ok1 && ok2 && ok3 {
		return fn(v1, v2, v3)
	}

	return
}

func ApplyCtxErrOn3[T1, T2, T3 any](
	ctx context.Context, t1 Opt[T1], t2 Opt[T2], t3 Opt[T3],
	fn func(ctx context.Context, t1 T1, t2 T2, t3 T3) (err error),
) (err error) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()
	v3, ok3 := t3.Get()

	if ok1 && ok2 && ok3 {
		return fn(ctx, v1, v2, v3)
	}

	return
}

func Apply3[T1, T2, T3, R1 any](
	t1 Opt[T1], t2 Opt[T2], t3 Opt[T3],
	fn func(t1 T1, t2 T2, t3 T3) (r1 R1),
) (r1 Opt[R1]) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()
	v3, ok3 := t3.Get()

	if ok1 && ok2 && ok3 {
		x1 := fn(v1, v2, v3)

		return Literal(x1)
	}

	return
}

func ApplyCtx3[T1, T2, T3, R1 any](
	ctx context.Context, t1 Opt[T1], t2 Opt[T2], t3 Opt[T3],
	fn func(ctx context.Context, t1 T1, t2 T2, t3 T3) (r1 R1),
) (r1 Opt[R1]) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()
	v3, ok3 := t3.Get()

	if ok1 && ok2 && ok3 {
		x1 := fn(ctx, v1, v2, v3)

		return Literal(x1)
	}

	return
}

func ApplyErr3[T1, T2, T3, R1 any](
	t1 Opt[T1], t2 Opt[T2], t3 Opt[T3],
	fn func(t1 T1, t2 T2, t3 T3) (r1 R1, err error),
) (r1 Opt[R1], err error) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()
	v3, ok3 := t3.Get()

	if ok1 && ok2 && ok3 {
		x1, err := fn(v1, v2, v3)

		return Literal(x1), err
	}

	return
}

func ApplyCtxErr3[T1, T2, T3, R1 any](
	ctx context.Context, t1 Opt[T1], t2 Opt[T2], t3 Opt[T3],
	fn func(ctx context.Context, t1 T1, t2 T2, t3 T3) (r1 R1, err error),
) (r1 Opt[R1], err error) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()
	v3, ok3 := t3.Get()

	if ok1 && ok2 && ok3 {
		x1, err := fn(ctx, v1, v2, v3)

		return Literal(x1), err
	}

	return
}

func Apply32[T1, T2, T3, R1, R2 any](
	t1 Opt[T1], t2 Opt[T2], t3 Opt[T3],
	fn func(t1 T1, t2 T2, t3 T3) (r1 R1, r2 R2),
) (r1 Opt[R1], r2 Opt[R2]) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()
	v3, ok3 := t3.Get()

	if ok1 && ok2 && ok3 {
		x1, x2 := fn(v1, v2, v3)

		return Literal(x1), Literal(x2)
	}

	return
}

func ApplyCtx32[T1, T2, T3, R1, R2 any](
	ctx context.Context, t1 Opt[T1], t2 Opt[T2], t3 Opt[T3],
	fn func(ctx context.Context, t1 T1, t2 T2, t3 T3) (r1 R1, r2 R2),
) (r1 Opt[R1], r2 Opt[R2]) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()
	v3, ok3 := t3.Get()

	if ok1 && ok2 && ok3 {
		x1, x2 := fn(ctx, v1, v2, v3)

		return Literal(x1), Literal(x2)
	}

	return
}

func ApplyErr32[T1, T2, T3, R1, R2 any](
	t1 Opt[T1], t2 Opt[T2], t3 Opt[T3],
	fn func(t1 T1, t2 T2, t3 T3) (r1 R1, r2 R2, err error),
) (r1 Opt[R1], r2 Opt[R2], err error) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()
	v3, ok3 := t3.Get()

	if ok1 && ok2 && ok3 {
		x1, x2, err := fn(v1, v2, v3)

		return Literal(x1), Literal(x2), err
	}

	return
}

func ApplyCtxErr32[T1, T2, T3, R1, R2 any](
	ctx context.Context, t1 Opt[T1], t2 Opt[T2], t3 Opt[T3],
	fn func(ctx context.Context, t1 T1, t2 T2, t3 T3) (r1 R1, r2 R2, err error),
) (r1 Opt[R1], r2 Opt[R2], err error) {
	v1, ok1 := t1.Get()
	v2, ok2 := t2.Get()
	v3, ok3 := t3.Get()

	if ok1 && ok2 && ok3 {
		x1, x2, err := fn(ctx, v1, v2, v3)

		return Literal(x1), Literal(x2), err
	}

	return
}
