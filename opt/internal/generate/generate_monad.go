//go:build generate_monad

package main

import (
	"bytes"
	_ "embed"
	"fmt"
	"os"
	"os/exec"
	"strings"
	"text/template"
)

const (
	maxArgs = 3
	maxRes  = 2
)

var (
	funcMap = template.FuncMap{
		"add": func(x, y int) int { return x + y },
	}

	//go:embed tmpl/apply.go.tmpl
	applyRaw  string
	applyTmpl = template.Must(template.New("apply").Funcs(funcMap).Parse(applyRaw))
)

type Variant struct {
	N, M int
	Ctx  bool
	Err  bool
}

func main() {
	pkg := detectPackageName()

	var buf bytes.Buffer
	buf.WriteString("// Code generated by generate_monad.go; DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", pkg))
	buf.WriteString("//go:generate go run internal/generate/generate_monad.go\n")
	buf.WriteString("import (\n\t\"context\"\n)\n")

	for n := 1; n <= maxArgs; n++ {
		for m := 0; m <= maxRes; m++ {
			for _, args := range []Variant{
				{n, m, false, false},
				{n, m, true, false},
				{n, m, false, true},
				{n, m, true, true},
			} {

				err := applyTmpl.Execute(&buf, args)
				if err != nil {
					panic(err)
				}
				//execTemplate(monadTmpl, "Monad", args, &buf)
			}
		}
	}

	err := os.WriteFile("monad.go", buf.Bytes(), 0644)
	if err != nil {
		panic(err)
	}
	fmt.Println("done")
}

// —————————————————————————————————————————————————————————————
// Templates
// —————————————————————————————————————————————————————————————

var monadTmpl = `
func Monad{{.N}}{{.Suffix}}{{.TypeArgs}}(fn func({{if .Ctx}}context.Context, {{end}}{{range $i, $n := .TypeNames}}{{$n}}{{if ne $n (index $.TypeNames | last)}}, {{end}}{{end}}) {{if .Err}}(R, error){{else}}R{{end}}) {{if .Ctx}}func(context.Context) func({{range $i, $n := .ArgNums}}Opt[T{{$n}}]{{if ne $n $.N}}, {{end}}{{end}}) {{.RetType}} {{else}}func({{range $i, $n := .ArgNums}}Opt[T{{$n}}]{{if ne $n $.N}}, {{end}}{{end}}) {{.RetType}} {{end}}{
	{{if .Ctx}}return func(ctx context.Context) func({{range $i, $n := .ArgNums}}Opt[T{{$n}}]{{if ne $n $.N}}, {{end}}{{end}}) {{.RetType}} {
		return func({{range $i, $n := .ArgNums}}a{{$n}} Opt[T{{$n}}]{{if ne $n $.N}}, {{end}}{{end}}) {{.RetType}} {
			return Apply{{.N}}{{.Suffix}}({{.CtxArg}}{{range $i, $n := .ArgNums}}a{{$n}}{{if ne $n $.N}}, {{end}}{{end}}, fn)
		}
	}
	{{else}}return func({{range $i, $n := .ArgNums}}a{{$n}} Opt[T{{$n}}]{{if ne $n $.N}}, {{end}}{{end}}) {{.RetType}} {
		return Apply{{.N}}{{.Suffix}}({{range $i, $n := .ArgNums}}a{{$n}}{{if ne $n $.N}}, {{end}}{{end}}, fn)
	}
	{{end}}
}
`

func detectPackageName() string {
	out, err := exec.Command("go", "list", "-f", "{{.Name}}").Output()
	if err != nil {
		panic(err)
	}
	return strings.TrimSpace(string(out))
}
